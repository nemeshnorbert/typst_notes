#import "@preview/ilm:1.3.0": *

#set text(lang: "ru", region: "ru")

#show: ilm.with(
  title: [Обработка измерений типа детекций центра полосы
    в навигационном фильтре],
  author: "Николай Майоров",
  chapter-pagebreak: false,
  table-of-contents: none,
)

#set heading(numbering: "1.")
#set math.mat(delim: "[")

Формулируется математическая модель для измерений типа детекции центра полосы.
Рассматривается два варианта:

+ Обрабатывается смещение относительно центра полосы и угол движения в полосе
+ Обрабатывается набор точек, принадлежащих центру полосы

= Состояние ровера и определение ошибок

Для ровера оцениваются его географические координаты $phi, lambda, h$ (что
эквивалентно ECEF декартовых координатам $r^e$) и ориентация относительно
ENU --- $C^n_b$. Ошибка координат определена в осях ENU --- $Delta r^n$,
ошибка ориентации $phi.alt^n$ определена, как вектор малого поворота,
согласно следующему линеаризованному соотношению между оценкой и истиной
ориентацией $hat(C)^n_b approx (I - (phi.alt^n times)) C^n_b$.

= Представление линии центра полосы и её проекция в связанные оси

Дорога в HD-картах представляется в виде кусочков "lanelet", каждый из которых
имеет центр полосы, представляемый в виде последовательности точек, заданных
координатами в ECEF. Для данных координат ровера можно получить ближайший
отрезок линии центра полосы. Таким образом, каждое измерение производится для
отрезка, заданного двумя ECEF координатами начала и конца --- $r^e_1$ и $r^e_2$.

Проекция полосы заключается в вычислении относительных координат начала и
вектора направления отрезка в связанных осях: $
p^b equiv mat(x_0, y_0, z_0)^T = C^b_e (r_1^e - r^e) \
tau^b equiv mat(tau_x, tau_y, tau_z)^T = C^b_e (r_2^e - r_1^e)
$
Для простоты предполагается, что система координат CV совпадает со связанной
системой координат, для которой получается навигационное решение.

= Обработка измерений типа смещения и угла

В этой модели предполагается, что система дает нам агрегированные измерения,
которые описывают прямую центра полосы в виде смещения и угла. Вместо этих двух
параметров можно было бы использовать и другие -- например коэффициент и
свободный член уравнения прямой, принципиально это не будет влиять на работу
алгоритма. Также нужно отметить, что по смыслу эти параметры будут
коррелированны, поэтому теоретически их нужно обрабатывать, как одно измерение
(на практике однако можно от этого отклониться, вопрос во многом эмпирический).

== Математическое определение измерений

Измерение концептуально производится следующим образом:

+ Отрезок центра полосы проецируется в связанные оси.
  Спроецированный отрезок задает луч, направление которого выбирается вдоль
  продольной оси ровера
+ Смещение в полосе вычисляется, как знаковое расстояние от центра связанной
  системы координат до проекции луча в плоскость $x y$
+ Угол движения в полосе вычисляется, как угол между осью $x$ и проекцией луча
  в плоскость $x y$

Указанная проекция отрезка центра полосы неявно производится как раз системой
компьютерного зрения. Эта система включает обработку двумерных изображений с
камеры, а также переход от двумерного образа полосы в связанные оси в
трехмерном пространстве. Вся эта процедура является нетривиальной, её точность
и стабильность сильно зависит от конкретной реализации. От чего в свою очередь
зависит эффективность использования и полезность таких измерений в
навигационном фильтре.

== Формулы для измерений

Смещение вычисляется, как знаковое расстояние от начала связанной системы
координат до проекции луча в плоскость $x y$:$
s = (-tau_y x_0 + tau_x y_0) / sqrt(tau_x^2 + tau_y^2) = (eta^b)^T p^b
$
Где введен единичный вектор нормали в плоскости $x y$:
$
  eta^b
  = 1 / norm(tau^b_h) mat(-tau_y; tau_x; 0), text("где") norm(tau^b_h)
  = sqrt(tau_x^2 + tau_y^2)
$

Угол движения в полосе вычисляется, как угол между осью x и
проекцией $tau^b$ в плоскость xy: $
beta = op("atan2")(tau_y, tau_x)
$

Здесь предполагалось, что вектор $tau^b$ имеет положительную $x$-компоненту,
если в вычислениях это оказывается не так, то его надо взять с обратным знаком.

== Связь ошибки предсказания измерений фильтром с ошибками оценок

Навигационный фильтр также получает на вход координаты концов отрезка центра
полосы и вычисляет свои предсказания смещения и угла движения, используя
текущие оценки координат и ориентации. Пока будем предполагать, что фильтр
получает на вход правильные координаты концов отрезка центра полосы (или
точнее, что они задают правильную прямую в пространстве). В простейшей логике
выбора ближайшей полосы успех будет зависеть от величины ошибок координат,
геометрии дороги и устройства полос в текущей окрестности.

Ошибки предсказаний в линейном приближении будут зависеть от ошибок вычисления
$p^b$ и $tau^b$ следующим образом:
$Delta s
  = ((partial s) / (partial p))^T Delta p^b
  + ((partial s) / (partial tau))^T Delta tau^b \
  Delta beta = ((partial beta) / (partial tau))^T Delta tau^b$
Где векторы частных производных имеют вид:
$
  (partial s) / (partial p) = eta^b \
  (partial s) / (partial tau)
  = -(x_0 tau_x + y_0 tau_y) / norm(tau^b_h)^2 eta^b \
  (partial beta) / (partial tau) = 1 / norm(tau^b_h) eta^b
$

Ошибки же проекций связаны с ошибками состояния ровера следующим образом:
$
  Delta p^b = -C^b_n Delta r^n - (p^b times) C^b_n phi.alt^n \
  Delta tau^b = -(tau^b times) C^b_n phi.alt^n
$

Скомбинировав эти формулы получим:
$
  Delta s = -((partial s) / (partial p))^T C^b_n Delta r^n
  - (((partial s) / (partial tau))^T (tau^b times)
    + ((partial s) / (partial p))^T (p^b times)) C^b_n phi.alt^n \
  Delta beta
  = -((partial beta) / (partial tau))^T (tau^b times) C^b_n phi.alt^n
$

=== Проверка для простой геометрии

Предположим, что ровер движется строго горизонтально с нулевым курсом и полоса
идет строго параллельно его продольной оси. В этом случае формулы для всех
элементов упрощаются $
C^n_b = I \
tau^b = mat(tau_x, 0, 0)^T \
eta^b  = mat(0, 1, 0)^T \
(partial s) / (partial p) = mat(0, 1, 0)^T \
(partial s) / (partial tau) = mat(0, -x_0 / tau_x, 0)^T \
(partial beta) / (partial tau) = mat(0, 1 / tau_x, 0)^T
$
Подставляя в формулы для ошибок предсказания, получим $
Delta s = -Delta r_N - z_0 phi.alt_E = -Delta r_Y + z_0 Delta gamma \
Delta beta = phi.alt_U = -Delta psi
$ <simple-jac>
Где $Delta r_Y, Delta gamma, Delta psi$ обозначают ошибку позиции в боковом
направлении, ошибку угла крена и курса соответственно.

Эти формулы согласуются с интуитивным представлением, как должны работать
такие измерения.

Ошибка смещения напрямую связана с ошибкой координат в боковом направлении.
А влияние ошибки угла крена пропорционально вертикальному разнесению центра
измерительной системы и плоскости дороги. Геометрически можно удостовериться,
что такой эффект действительно должен проявляться --- при крене плоскости xy
линия полосы начнет проецироваться со смещением вдоль оси y.

Ошибка угла движения в полосе напрямую связана с ошибкой угла курса.

= Обработка "сырых" точек

В этом варианте предполагается, что CV доставляет набор двумерных координат
точек, каждая из которых с точностью до ошибок принадлежит прямой центра полосы.
Здесь естественно предполагать, что каждое такое измерение независимо, поэтому
достаточно рассмотреть алгоритм обработки одной такой точки.

При идеальной оценке состояния ровера, точности HD карты и измерений, точки
будут строго ложиться на прямую центра полосы. В качестве корректирующих
сигналов (невязок) можно предложить два варианта:

+ Расстояние от точки до прямой. В этом случае естественно предполагать ошибку
  измерений в обеих координатах $x$ и $y$, такой метод аналогичен задаче
  полных наименьшие квадратов
+ Отклонение предсказанной координаты $y$ от измеренной. В этом случае ошибка
  предполагается только в измерениях $y$, что соответствует обычной задаче
  наименьших квадратов

Первый подход выглядит более геометрически правильным и совершенным, но он
более сложен в плане реализации, формировании матриц для измерения (возможно
содержит нюансы, которые сразу не предусмотришь). Второй подход более простой
и понятный, сначала будет разработан именно он.

== Предсказание координаты $y$

Уравнение прямой центра полосы в связанных координатах в канонической форме
имеет вид $
tau_y (x - x_0) - tau_x (y - y_0) = 0
$
Из него можно выразить $y$ напрямую
$
  y = k x + b, text("где") k = tau_y / tau_x, b = y_0 - k x_0
$
Такой вид уравнения хорошо определен если $tau_x$ существенно отличается от
нуля, при движении в полосе это будет выполняться.

Предсказание координаты $y$ производится для измеренной координаты $tilde(x)$
с помощью текущих оценок: $ hat(y) = hat(k) tilde(x) + hat(b) $
Параметры $hat(k)$ и $hat(b)$ вычисляются по формулам, используя текущие оценки
состояния ровера.

== Связь невязки с ошибками состояния

Нужно записать связь ошибки предсказания $hat(y)$ с ошибками состояния:
$
  Delta y
  = tilde(x) ((partial k) / (partial tau))^T Delta tau
  + ((partial y_0) / (partial p))^T Delta p
  - x_0 ((partial k) / (partial tau))^T Delta tau
  - k ((partial x_0) / (partial p))^T Delta p \
  Delta y
  = (tilde(x) - x_0) ((partial k) / (partial tau))^T Delta tau
  + ((partial b) / (partial p))^T Delta p
$
Где векторы частных производных имеют вид:
$
  (partial k) / (partial tau) = 1 / tau_x mat(-tau_y / tau_x; 1; 0) \
  (partial b) / (partial p) equiv (partial y_0) / (partial p)
  - k (partial x_0) / (partial p) = mat(-k; 1; 0)
$
Подставив выражения для ошибок $tau$ и $p$ через ошибки состояния получим:
$
  Delta y = -((partial b) / (partial p))^T C^b_n Delta r_n
  - ((tilde(x) - x_0) ((partial k) / (partial tau))^T (tau^b times)
    + ((partial b) / (partial p))^T (p^b times) ) C^b_n phi.alt^n
$
Если заметить соотношение
$ (partial k) / (partial tau) = 1 / tau_x (partial b) / (partial p) $,
то формулу можно записать в более кратком виде:
$
  Delta y = -((partial b) / (partial p))^T C^b_n Delta r_n
  - ((partial b) / (partial p))^T ((tilde(x) - x_0) / tau_x (tau^b times)
    + (p^b times) ) C^b_n phi.alt^n
$

=== Проверка для простой геометрии

Рассмотрим такую же ситуацию, как в предыдущем разделе. В этом случае будет
$
  k = 0 \
  (partial b) / (partial p) = mat(0; 1; 0)
$
Подставив все выражения в формулу найдем:
$
  Delta y = -Delta r_N - z_0 phi.alt_E + tilde(x) phi.alt_U = -Delta r_Y
  + z_0 Delta gamma - tilde(x) Delta psi
$
Где $Delta r_Y, Delta gamma, Delta psi$ обозначают ошибку позиции в боковом
направлении, ошибку угла крена и курса соответственно.

Здесь мы видим три слагаемых:

+ Первое напрямую соответствует ошибке координат в боковом направлении
+ Второе связано с ошибкой крена, эффект пропорционален высоте центра системы
  компьютерного зрения
+ Третье связано с ошибкой угла курса, при этом коэффициентом
  пропорциональности выступает продольная координата наблюдаемой точки.
  Т. е. чем дальше точка, тем больше курсовая ошибка ровера влияет на
  предсказание её $y$ координаты. Нужно также отметить, что в реализации СКО
  шума измерения имеет смысл также назначать пропорционально данному
  расстоянию, т. к. системы компьютерного зрения хуже различают объекты
  на большом удалении

Если сравнить с @simple-jac, то мы увидим, что оба подхода в плане
измерительной информации принципиально не различаются.
